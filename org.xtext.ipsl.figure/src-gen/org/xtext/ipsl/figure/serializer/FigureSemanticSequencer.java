/*
 * generated by Xtext 2.30.0
 */
package org.xtext.ipsl.figure.serializer;

import com.google.inject.Inject;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;
import org.xtext.ipsl.figure.figure.CARRE;
import org.xtext.ipsl.figure.figure.CERCLE;
import org.xtext.ipsl.figure.figure.FIGURE;
import org.xtext.ipsl.figure.figure.FigurePackage;
import org.xtext.ipsl.figure.figure.PROGRAMME;
import org.xtext.ipsl.figure.figure.RECTANGLE;
import org.xtext.ipsl.figure.figure.REEL;
import org.xtext.ipsl.figure.figure.RETURN;
import org.xtext.ipsl.figure.services.FigureGrammarAccess;

@SuppressWarnings("all")
public class FigureSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private FigureGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == FigurePackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case FigurePackage.CARRE:
				sequence_CARRE(context, (CARRE) semanticObject); 
				return; 
			case FigurePackage.CERCLE:
				sequence_CERCLE(context, (CERCLE) semanticObject); 
				return; 
			case FigurePackage.FIGURE:
				sequence_FIGURE(context, (FIGURE) semanticObject); 
				return; 
			case FigurePackage.PROGRAMME:
				sequence_PROGRAMME(context, (PROGRAMME) semanticObject); 
				return; 
			case FigurePackage.RECTANGLE:
				sequence_RECTANGLE(context, (RECTANGLE) semanticObject); 
				return; 
			case FigurePackage.REEL:
				sequence_REEL(context, (REEL) semanticObject); 
				return; 
			case FigurePackage.RETURN:
				sequence_RETURN(context, (RETURN) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * <pre>
	 * Contexts:
	 *     CARRE returns CARRE
	 *
	 * Constraint:
	 *     (nom='Carre' debut=DEBUT cote=REEL retour=RETURN end=END)
	 * </pre>
	 */
	protected void sequence_CARRE(ISerializationContext context, CARRE semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, FigurePackage.Literals.CARRE__NOM) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FigurePackage.Literals.CARRE__NOM));
			if (transientValues.isValueTransient(semanticObject, FigurePackage.Literals.CARRE__DEBUT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FigurePackage.Literals.CARRE__DEBUT));
			if (transientValues.isValueTransient(semanticObject, FigurePackage.Literals.CARRE__COTE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FigurePackage.Literals.CARRE__COTE));
			if (transientValues.isValueTransient(semanticObject, FigurePackage.Literals.CARRE__RETOUR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FigurePackage.Literals.CARRE__RETOUR));
			if (transientValues.isValueTransient(semanticObject, FigurePackage.Literals.CARRE__END) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FigurePackage.Literals.CARRE__END));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getCARREAccess().getNomCarreKeyword_0_0(), semanticObject.getNom());
		feeder.accept(grammarAccess.getCARREAccess().getDebutDEBUTParserRuleCall_1_0(), semanticObject.getDebut());
		feeder.accept(grammarAccess.getCARREAccess().getCoteREELParserRuleCall_2_2_0(), semanticObject.getCote());
		feeder.accept(grammarAccess.getCARREAccess().getRetourRETURNParserRuleCall_3_0(), semanticObject.getRetour());
		feeder.accept(grammarAccess.getCARREAccess().getEndENDParserRuleCall_4_0(), semanticObject.getEnd());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     CERCLE returns CERCLE
	 *
	 * Constraint:
	 *     (nom='Cercle' debut=DEBUT rayon=REEL retour=RETURN end=END)
	 * </pre>
	 */
	protected void sequence_CERCLE(ISerializationContext context, CERCLE semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, FigurePackage.Literals.CERCLE__NOM) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FigurePackage.Literals.CERCLE__NOM));
			if (transientValues.isValueTransient(semanticObject, FigurePackage.Literals.CERCLE__DEBUT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FigurePackage.Literals.CERCLE__DEBUT));
			if (transientValues.isValueTransient(semanticObject, FigurePackage.Literals.CERCLE__RAYON) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FigurePackage.Literals.CERCLE__RAYON));
			if (transientValues.isValueTransient(semanticObject, FigurePackage.Literals.CERCLE__RETOUR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FigurePackage.Literals.CERCLE__RETOUR));
			if (transientValues.isValueTransient(semanticObject, FigurePackage.Literals.CERCLE__END) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FigurePackage.Literals.CERCLE__END));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getCERCLEAccess().getNomCercleKeyword_0_0(), semanticObject.getNom());
		feeder.accept(grammarAccess.getCERCLEAccess().getDebutDEBUTParserRuleCall_1_0(), semanticObject.getDebut());
		feeder.accept(grammarAccess.getCERCLEAccess().getRayonREELParserRuleCall_2_2_0(), semanticObject.getRayon());
		feeder.accept(grammarAccess.getCERCLEAccess().getRetourRETURNParserRuleCall_3_0(), semanticObject.getRetour());
		feeder.accept(grammarAccess.getCERCLEAccess().getEndENDParserRuleCall_4_0(), semanticObject.getEnd());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     FIGURE returns FIGURE
	 *
	 * Constraint:
	 *     (nom=CERCLE | nom=RECTANGLE | nom=CARRE)
	 * </pre>
	 */
	protected void sequence_FIGURE(ISerializationContext context, FIGURE semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     PROGRAMME returns PROGRAMME
	 *
	 * Constraint:
	 *     fig=FIGURE
	 * </pre>
	 */
	protected void sequence_PROGRAMME(ISerializationContext context, PROGRAMME semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, FigurePackage.Literals.PROGRAMME__FIG) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FigurePackage.Literals.PROGRAMME__FIG));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPROGRAMMEAccess().getFigFIGUREParserRuleCall_0(), semanticObject.getFig());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     RECTANGLE returns RECTANGLE
	 *
	 * Constraint:
	 *     (nom='Rectangle' debut=DEBUT (longueur=REEL | largeur=REEL)+ retour=RETURN end=END)
	 * </pre>
	 */
	protected void sequence_RECTANGLE(ISerializationContext context, RECTANGLE semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     REEL returns REEL
	 *
	 * Constraint:
	 *     reel=DOUBLE
	 * </pre>
	 */
	protected void sequence_REEL(ISerializationContext context, REEL semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, FigurePackage.Literals.REEL__REEL) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FigurePackage.Literals.REEL__REEL));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getREELAccess().getReelDOUBLETerminalRuleCall_0(), semanticObject.getReel());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     RETURN returns RETURN
	 *
	 * Constraint:
	 *     resultat=RETOUR
	 * </pre>
	 */
	protected void sequence_RETURN(ISerializationContext context, RETURN semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, FigurePackage.Literals.RETURN__RESULTAT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FigurePackage.Literals.RETURN__RESULTAT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getRETURNAccess().getResultatRETOURParserRuleCall_1_0(), semanticObject.getResultat());
		feeder.finish();
	}
	
	
}
